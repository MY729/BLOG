(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{459:function(t,e,a){"use strict";a.r(e);var r=a(56),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),a("h2",{attrs:{id:"part1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#part1"}},[t._v("#")]),t._v(" part1")]),t._v(" "),a("h3",{attrs:{id:"_1-vue响应式原理阐述一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue响应式原理阐述一下"}},[t._v("#")]),t._v(" 1. Vue响应式原理阐述一下")]),t._v(" "),a("p",[t._v("当创建Vue实例的时候，Vue会遍历data的属性，，通过Object.defineProperty为属性添加setter和getter, 对数据进行劫持")]),t._v(" "),a("p",[t._v("getter: 依赖收集")]),t._v(" "),a("p",[t._v("setter：派发更新")]),t._v(" "),a("p",[t._v("每个组件的示例都会有对应的watch实例，数据发生更新时，会触发属性的getter依赖收集，当改变相应值，setter会通知订阅者执行更新")]),t._v(" "),a("h3",{attrs:{id:"_2-计算属性的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-计算属性的实现原理"}},[t._v("#")]),t._v(" 2. 计算属性的实现原理")]),t._v(" "),a("p",[t._v("当计算属性的依赖值发生改下，会通知订阅者进行更新")]),t._v(" "),a("p",[t._v("注意：计算属性里面的依赖值必须是vue实例化的data里面定义过的，才能实时计算，否则因为没有走劫持的过程，是监听不到变化的")]),t._v(" "),a("h3",{attrs:{id:"_3-vue-nexttick的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-nexttick的原理"}},[t._v("#")]),t._v(" 3. vue.nextTick的原理")])])}),[],!1,null,null,null);e.default=s.exports}}]);